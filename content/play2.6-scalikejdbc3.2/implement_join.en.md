---
title: Implementing JOIN
---


Up until now, we have used methods automatically generated by scalikejdbcGen and simple QueryDSL, but let's try to implement the complex cases where it is required to join tables.

We can see the companyName on the user list page.

![Display company name on user list page](../images/play2.6-scalikejdbc3.2/user_list_companies.png)

## Modify the Controller

We will first fix the `list` method of `UserController`.

```scala
def list = Action { implicit request =>
  DB.readOnly { implicit session =>
    // fetch user list
    val users = withSQL {
      select.from(Users as u).leftJoin(Companies as c).on(u.companyId, c.id).orderBy(u.id.asc)
    }.map { rs =>
      (Users(u)(rs), rs.intOpt(c.resultName.id).map(_ => Companies(c)(rs)))
    }.list.apply()

   // display user list
    Ok(views.html.user.list(users))
  }
}
```

Note that we need to convert to the `Option` type in the`map()` method if we want to get the value of the outer joined table. The code below first gets the `ID` column of the` COMPANIES` table from the result set as `Option[Int]` type using the `intOpt` method and if value is obtained then maps it to the` Companies` class.

```scala
rs.intOpt(c.resultName.id).map(_ => Companies(c)(rs))
```

Furthermore, in the case of inner join, we can use `innerJoin` method instead of` leftJoin`. In this case, there is no need to convert to the `Option` type in ` map()`method.

## Modify View

We will now modify the `list.scala.html` file. Change the search result type to `List[(Users, Option[Companies])]` from `List[Users]`、add the `company name` row into the view.

```html
@(users: Seq[(models.Users, Option[models.Companies])])(implicit request: RequestHeader)
@import helper._
@main("ユーザ一覧") {
<div>
  <a href="@routes.UserController.edit()" class="btn btn-success" role="button">新規作成</a>
</div>
<div class="col-xs-6">
  <table class="table table-hover">
    <thead>
      <tr>
        <th>ID</th>
        <th>名前</th>
        <th>会社名</th>
        <th>&nbsp;</th>
      </tr>
    </thead>
    <tbody>
    @users.map { case (user, company) =>
      <tr>
        <td>@user.id</td>
        <td><a href="@routes.UserController.edit(Some(user.id))">@user.name</a></td>
        <td>@company.map(_.name)</td>
        <td>@helper.form(CSRF(routes.UserController.remove(user.id))){
          <input type="submit" value="削除" class="btn btn-danger btn-xs"/>
        }
        </td>
      </tr>
    }
    </tbody>
  </table>
</div>
}
```

When we access the user list page, we should see a screen like the first capture.

## Write SQL directly

We wrote a join query using a typesafe DSL, but in the case of slightly more complex SQL such as aggregation, we would like to write it directly.

We can write raw SQL with string literals using `sql` interpolation. However, in addition to completely describing SQL, we can also use an automatically generated class to assist in the description.

```scala
val users: Seq[(Users, Companies)] = sql"""
  |SELECT ${u.result.*}, ${c.result.*}
  |FROM ${Users.as(u)} INNER JOIN ${Companies.as(c)}
  |ON ${u.companyId} = ${c.id}
""".stripMargin.map { rs =>
  (Users(u)(rs), Companies(c)(rs))
}.list.apply()
```

By using the above format, there is no need to write a large number of columns in the SELECT clause, and also it is possible to prevent a typo in table names and column names. Furthermore, when using `sql` interpolation, it is not necessary to enclose it with `withSQL {...}`. 
The steps after the `map ()` method are the same as in QueryDSL.

## References

The following documents can be used references for details of search processing in ScalikeJDBC.

- http://scalikejdbc.org/documentation/query-dsl.html
- http://scalikejdbc.org/documentation/sql-interpolation.html
