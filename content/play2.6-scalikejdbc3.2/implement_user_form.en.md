---
title: Implement the edit page
---

Depending on whether the ID is specified in the request parameter, the following processing is performed.

* If ID is not present in request ⇒ Display the new registration screen
* ID is present in request parameter ⇒ Search the `USERS` table and display the edit screen that displays the initialized user information.

## Form

Define a `Form` to receive input values ​​from the screen. `Form` does not necessarily need to be defined in the controller, but it depends strongly on methods of the controller, so it is better to define it in the companion object of the controller class unless there is any specific reason.

Define the companion object in the same source file of `UserController` class.

```scala
object UserController {
  // case class for storing form values
  case class UserForm(id: Option[Long], name: String, companyId: Option[Int])

  // data sent from form ⇔ case class conversion
  val userForm = Form(
    mapping(
      "id"        -> optional(longNumber),
      "name"      -> nonEmptyText(maxLength = 20),
      "companyId" -> optional(number)
    )(UserForm.apply)(UserForm.unapply)
  )
}
```

A companion object is an object defined with the same name in the same file as a class or trait. The companion object and the class or trait corresponding to the companion object can access private members of each other. It is used to group common methods and classes used in classes and traits.

> **POINT**
>
> * A companion object is an object defined with the same name in the same file as the class
> * `Form` is similar to a Struts action form.
> * A Validation (described later) is performed according to the mapping.

## View

Now, we will implement the `edit.scala.html` in the` views.user` package. It takes `Form` instance and` Seq[Companies]`, to be selected from the pull-down menu, as arguments.

```html
@(userForm: Form[controllers.UserController.UserForm], companies: Seq[models.Companies])(implicit request: MessagesRequestHeader)

@import helper._

@main("ユーザ作成") {

  @* If there is an ID, call the update process, if not, call the registration process *@
  @form(CSRF(userForm("id").value.map(x => routes.UserController.update).getOrElse(routes.UserController.create)), 'class -> "container", 'role -> "form") {
    <fieldset>
      <div class="form-group">
        @inputText(userForm("name"), '_label -> "名前")
      </div>
      <div class="form-group">
        @select(userForm("companyId"), companies.map(x => x.id.toString -> x.name).toSeq, '_label -> "会社", '_default -> "-- 会社名を選択してください --")
      </div>
      @* IDがある場合（更新の場合）のみhiddenを出力する *@
      @userForm("id").value.map { value =>
        <input type="hidden" name="id" value="@value" />
      }
      <div>
        <input type="submit" value="保存" class="btn btn-success">
      </div>
    </fieldset>
  }

}
```

This template accepts `MessagesRequestHeader` as an implicit argument, which is required for internationalization of messages by `inputText`. `inpuText` is helper function used to display the text field in the template. It will be passed implicitly if` MessagesControllerComponents` is DI in the controller. `MessagesRequestHeader` is not required in this hands-on, but you should remember it because it is necessary for internationalization of the Play2 application.

## Controller

Now, implement the `edit` method in `UserController`. If `id` is not specified in argument, then an empty` Form` is defined otherwise `Form#fill` method sets the initial value in the` Form` and calls the template.

```scala
// add import statement to refer to Form defined in companion object
import UserController._

private val c = Companies.syntax("c")

def edit(id: Option[Long]) = Action { implicit request =>
  DB.readOnly { implicit session =>
    val form = id match {
      // if ID is not passed, then return the new registration form 
      case None => userForm
      // Retrieve 1 user information from ID and bind it into the form
      case Some(id) => Users.find(id) match {
        case Some(user) => userForm.fill(UserForm(Some(user.id), user.name, user.companyId))
        case None => userForm
      }
    }

    // get list of companies to be displayed in the pull-down box
    val companies = withSQL {
      select.from(Companies as c).orderBy(c.id.asc)
    }.map(Companies(c.resultName)).list().apply()

    Ok(views.html.user.edit(form, companies))
  }
}
```

In the above code, if the parameter `id` is not specified (in the case of` None`), then an empty form for new registration is specified, and if ID is provided (in the case of `Some (id)`), then the update form is used. At that time, `Users.find (id)` gets user information from DB to set into the update form. This method is a search method automatically generated by scalikejdbcGen. And in the above manner, basic CRUD processing can be implemented with the help of automatically generated methods.

We can also rewrite the above method with QueryDSL.

```scala
 // one item search can rewritten with QueryDSL
withSQL {
  select.from(Users as u).where.eq(u.id, id)
}.map(Users(u.resultName)).single.apply()
```


In the following description, list of company is obtained.

```scala
val companies = withSQL {
  select.from(Companies as c).orderBy(c.id.asc)
}.map(Companies(c.resultName)).list().apply()
```

The QueryDSL of `select.from(Companies as c).orderBy(c.id.asc)` in the above code has the same meaning as the following SQL.

```sql
SELECT * FROM COMPANIES ORDER BY ID
```

## Run

Click the new registration or username link from the list page in the browser, and confirm that the registration screen or the edit screen are displayed accordingly as shown below.

![User Registration Pae](../images/play2.6-scalikejdbc3.2/register_form.png)

![User Edit Page](../images/play2.6-scalikejdbc3.2/edit_form.png)

